# Node-RED Spec Tests Diff
This file is automatically generated by the script `test/specs_diff.py` to compare the specification compliance of EdgeLink and Node-RED nodes. 
## common nodes
### inject
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~inject node inject id of flow as environment variable~~ |
| :white_check_mark: | ~~inject node inject id of flow as environment variable~~ |
| :white_check_mark: | ~~inject node inject id of group as environment variable~~ |
| :white_check_mark: | ~~inject node inject id of group as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject id of node as environment variable~~ |
| :white_check_mark: | ~~inject node inject id of node as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject name of flow as environment variable~~ |
| :white_check_mark: | ~~inject node inject name of flow as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject name of group as environment variable~~ |
| :white_check_mark: | ~~inject node inject name of group as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject name of node as environment variable~~ |
| :white_check_mark: | ~~inject node inject name of node as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject path of node as environment variable~~ |
| :white_check_mark: | ~~inject node inject path of node as environment variable by substitution~~ |
| :white_check_mark: | ~~inject node inject value (bin)~~ |
| :white_check_mark: | ~~inject node inject value (bool)~~ |
| :white_check_mark: | ~~inject node inject value (json)~~ |
| :white_check_mark: | ~~inject node inject value (num)~~ |
| :white_check_mark: | ~~inject node inject value (str)~~ |
| :white_check_mark: | ~~inject node inject value of environment variable~~ |
| :white_check_mark: | ~~inject node should inject multiple properties~~ |
| :white_check_mark: | ~~inject node should inject multiple properties using legacy props if needed~~ |
| :white_check_mark: | ~~inject node should inject once with 500 msec. delay~~ |
| :white_check_mark: | ~~inject node should inject once with default delay~~ |
| :white_check_mark: | ~~inject node should inject once with default delay property~~ |
| :white_check_mark: | ~~inject node should inject once with delay of two seconds~~ |
| :white_check_mark: | ~~inject node should inject once with delay of two seconds and repeatedly~~ |
| :white_check_mark: | ~~inject node should inject repeatedly~~ |
| :white_check_mark: | ~~inject node should inject with cron~~ |
| :x: | **inject node post should fail for invalid node** |
| :x: | **inject node post should inject custom properties in posted message** |
| :x: | **inject node post should inject message** |
| :x: | **inject node sets the value of flow context property** |
| :x: | **inject node sets the value of global context property** |
| :x: | **inject node sets the value of persistable flow & global context property** |
| :x: | **inject node sets the value of persistable flow context property** |
| :x: | **inject node sets the value of persistable global context property** |
| :x: | **inject node sets the value of two persistable flow context property** |
| :x: | **inject node sets the value of two persistable global context property** |
| :x: | **inject node sets the value of two persistable global context property** |
| :x: | **inject node should inject custom properties in message** |
| :x: | **inject node should report invalid JSONata expression** |
### catch
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~catch Node should output a message when called~~ |
### link
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~link Node link-call node should allow nested link-call flows~~ |
| :white_check_mark: | ~~link Node link-call node should call link-in node by name and get response~~ |
| :white_check_mark: | ~~link Node link-call node should call static link-in node and get response~~ |
| :white_check_mark: | ~~link Node should be linked~~ |
| :white_check_mark: | ~~link Node should be linked from multiple nodes~~ |
| :white_check_mark: | ~~link Node should be linked to multiple nodes~~ |
| :white_check_mark: | ~~link Node should be loaded (link in)~~ |
| :white_check_mark: | ~~link Node should be loaded (link out)~~ |
| :x: | **link Node link-call node should not raise error after deploying a name change to a duplicate link-in node** |
| :x: | **link Node link-call node should raise error due to multiple targets on different tabs** |
| :x: | **link Node link-call node should raise error due to multiple targets on same tab** |
| :x: | **link Node link-call node should timeout waiting for link return** |
## function nodes
### function
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~function node should allow accessing env vars~~ |
| :white_check_mark: | ~~function node should allow accessing node.id~~ |
| :white_check_mark: | ~~function node should allow accessing node.id and node.name and node.outputCount~~ |
| :white_check_mark: | ~~function node should allow accessing node.name~~ |
| :white_check_mark: | ~~function node should allow input to be discarded by returning null~~ |
| :white_check_mark: | ~~function node should clone first message sent using send() - array 1~~ |
| :white_check_mark: | ~~function node should clone first message sent using send() - array 2~~ |
| :white_check_mark: | ~~function node should clone first message sent using send() - array 3~~ |
| :white_check_mark: | ~~function node should clone first message sent using send() - array 3~~ |
| :white_check_mark: | ~~function node should clone single message sent using send()~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - array~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - boolean~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - buffer~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - number~~ |
| :white_check_mark: | ~~function node should drop and log non-object message types - string~~ |
| :white_check_mark: | ~~function node should execute initialization~~ |
| :white_check_mark: | ~~function node should get flow context~~ |
| :white_check_mark: | ~~function node should get flow context~~ |
| :white_check_mark: | ~~function node should get global context~~ |
| :white_check_mark: | ~~function node should get global context~~ |
| :white_check_mark: | ~~function node should get keys in default persistable node context~~ |
| :white_check_mark: | ~~function node should get keys in flow context~~ |
| :white_check_mark: | ~~function node should get keys in global context~~ |
| :white_check_mark: | ~~function node should get keys in node context~~ |
| :white_check_mark: | ~~function node should get keys in persistable flow context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get keys in persistable flow context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get keys in persistable node context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get keys in persistable node context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get node context~~ |
| :white_check_mark: | ~~function node should get persistable flow context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get persistable flow context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get persistable global context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get persistable global context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get persistable global context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get persistable global context (w/o callback)~~ |
| :white_check_mark: | ~~function node should get persistable node context (w/ callback)~~ |
| :white_check_mark: | ~~function node should get persistable node context (w/o callback)~~ |
| :white_check_mark: | ~~function node should handle clearInterval()~~ |
| :white_check_mark: | ~~function node should handle null amongst valid messages~~ |
| :white_check_mark: | ~~function node should handle setInterval()~~ |
| :white_check_mark: | ~~function node should handle setTimeout()~~ |
| :white_check_mark: | ~~function node should not clone single message sent using send(,false)~~ |
| :white_check_mark: | ~~function node should pass through _topic~~ |
| :white_check_mark: | ~~function node should send returned message~~ |
| :white_check_mark: | ~~function node should send returned message using send()~~ |
| :white_check_mark: | ~~function node should send returned message using send()~~ |
| :white_check_mark: | ~~function node should send to multiple messages~~ |
| :white_check_mark: | ~~function node should send to multiple outputs~~ |
| :white_check_mark: | ~~function node should set default persistable node context~~ |
| :white_check_mark: | ~~function node should set flow context~~ |
| :white_check_mark: | ~~function node should set global context~~ |
| :white_check_mark: | ~~function node should set node context~~ |
| :white_check_mark: | ~~function node should set persistable flow context (w/ callback)~~ |
| :white_check_mark: | ~~function node should set persistable flow context (w/o callback)~~ |
| :white_check_mark: | ~~function node should set persistable global context (w/ callback)~~ |
| :white_check_mark: | ~~function node should set persistable global context (w/o callback)~~ |
| :white_check_mark: | ~~function node should set persistable node context (w callback)~~ |
| :white_check_mark: | ~~function node should set persistable node context (w/o callback)~~ |
| :white_check_mark: | ~~function node should set two persistable flow context (w/ callback)~~ |
| :white_check_mark: | ~~function node should set two persistable flow context (w/o callback)~~ |
| :white_check_mark: | ~~function node should set two persistable node context (single call, w/o callback)~~ |
| :white_check_mark: | ~~function node should set two persistable node context (w callback)~~ |
| :white_check_mark: | ~~function node should set two persistable node context (w/o callback)~~ |
| :white_check_mark: | ~~function node should wait completion of initialization~~ |
| :x: | **function node Logger should catch thrown number** |
| :x: | **function node Logger should catch thrown object (bad practice)** |
| :x: | **function node Logger should catch thrown string** |
| :x: | **function node Logger should log a Debug Message** |
| :x: | **function node Logger should log a Debug Message - initialise** |
| :x: | **function node Logger should log a Trace Message** |
| :x: | **function node Logger should log a Trace Message - initialise** |
| :x: | **function node Logger should log a Warning Message** |
| :x: | **function node Logger should log a Warning Message - initialise** |
| :x: | **function node Logger should log an Error Message** |
| :x: | **function node Logger should log an Error Message - initialise** |
| :x: | **function node Logger should log an Info Message** |
| :x: | **function node Logger should log an Info Message - initialise** |
| :x: | **function node check if default function timeout settings are recognized** |
| :x: | **function node externalModules should fail if module variable name clashes with sandbox builtin** |
| :x: | **function node externalModules should fail if using OS module with functionExternalModules set to false** |
| :x: | **function node externalModules should fail if using OS module without it listed in libs** |
| :x: | **function node externalModules should require the OS module** |
| :x: | **function node finalize function should allow accessing node.id and node.name and node.outputCount** |
| :x: | **function node finalize function should execute** |
| :x: | **function node init function should allow accessing node.id and node.name and node.outputCount and sending message** |
| :x: | **function node init function should delay handling messages until init completes** |
| :x: | **function node should be loaded** |
| :x: | **function node should do something with the catch node** |
| :x: | **function node should handle and log script error** |
| :x: | **function node should handle error on get keys in persistable context** |
| :x: | **function node should handle error on get persistable context** |
| :x: | **function node should handle error on set persistable context** |
| :x: | **function node should handle node.on()** |
| :x: | **function node should set two persistable node context (single call, w callback)** |
| :x: | **function node should timeout if timeout is set** |
| :x: | **function node should use the same Date object from outside the sandbox** |
### switch
| Status | Spec Test |
| --- | --- |
| :x: | **switch Node handles more than one switch statement** |
| :x: | **switch Node sends a message when the "else/otherwise" statement is selected** |
| :x: | **switch Node sends nothing when input is false and checking for true** |
| :x: | **switch Node sends nothing when input is false and checking for true** |
| :x: | **switch Node should be able to use $I in JSONata expression** |
| :x: | **switch Node should be able to use $N in JSONata expression** |
| :x: | **switch Node should be loaded with some defaults** |
| :x: | **switch Node should check JSONata expression is true** |
| :x: | **switch Node should check if input is indeed false** |
| :x: | **switch Node should check if input is indeed not null** |
| :x: | **switch Node should check if input is indeed null** |
| :x: | **switch Node should check if input is indeed undefined** |
| :x: | **switch Node should check if input is true** |
| :x: | **switch Node should check if payload NOT equals given numeric value** |
| :x: | **switch Node should check if payload NOT equals given value** |
| :x: | **switch Node should check if payload contains given value** |
| :x: | **switch Node should check if payload equals given numeric value** |
| :x: | **switch Node should check if payload equals given value** |
| :x: | **switch Node should check if payload if of type JSON string** |
| :x: | **switch Node should check if payload if of type JSON string (and fail if not)** |
| :x: | **switch Node should check if payload if of type array** |
| :x: | **switch Node should check if payload if of type boolean false** |
| :x: | **switch Node should check if payload if of type boolean true** |
| :x: | **switch Node should check if payload if of type buffer** |
| :x: | **switch Node should check if payload if of type null** |
| :x: | **switch Node should check if payload if of type number** |
| :x: | **switch Node should check if payload if of type number 0** |
| :x: | **switch Node should check if payload if of type number Infinity** |
| :x: | **switch Node should check if payload if of type number NaN** |
| :x: | **switch Node should check if payload if of type object** |
| :x: | **switch Node should check if payload if of type string** |
| :x: | **switch Node should check if payload if of type undefined** |
| :x: | **switch Node should check if payload is between given string values** |
| :x: | **switch Node should check if payload is between given values** |
| :x: | **switch Node should check if payload is between given values in "wrong" order** |
| :x: | **switch Node should check if payload is empty (0)** |
| :x: | **switch Node should check if payload is empty (array)** |
| :x: | **switch Node should check if payload is empty (buffer)** |
| :x: | **switch Node should check if payload is empty (non-empty array)** |
| :x: | **switch Node should check if payload is empty (non-empty buffer)** |
| :x: | **switch Node should check if payload is empty (non-empty object)** |
| :x: | **switch Node should check if payload is empty (non-empty string)** |
| :x: | **switch Node should check if payload is empty (null)** |
| :x: | **switch Node should check if payload is empty (object)** |
| :x: | **switch Node should check if payload is empty (string)** |
| :x: | **switch Node should check if payload is empty (undefined)** |
| :x: | **switch Node should check if payload is greater than given value** |
| :x: | **switch Node should check if payload is greater than/equals given value** |
| :x: | **switch Node should check if payload is greater than/equals given value** |
| :x: | **switch Node should check if payload is less than given value** |
| :x: | **switch Node should check if payload is not between given values** |
| :x: | **switch Node should check if payload is not empty (0)** |
| :x: | **switch Node should check if payload is not empty (array)** |
| :x: | **switch Node should check if payload is not empty (buffer)** |
| :x: | **switch Node should check if payload is not empty (non-empty array)** |
| :x: | **switch Node should check if payload is not empty (non-empty buffer)** |
| :x: | **switch Node should check if payload is not empty (non-empty object)** |
| :x: | **switch Node should check if payload is not empty (non-empty string)** |
| :x: | **switch Node should check if payload is not empty (null)** |
| :x: | **switch Node should check if payload is not empty (object)** |
| :x: | **switch Node should check if payload is not empty (string)** |
| :x: | **switch Node should check if payload is not empty (undefined)** |
| :x: | **switch Node should check if payload less than equals given value** |
| :x: | **switch Node should check input against a previous value** |
| :x: | **switch Node should check input against a previous value (2nd option)** |
| :x: | **switch Node should handle JSONata expression** |
| :x: | **switch Node should handle empty rule** |
| :x: | **switch Node should handle env var expression** |
| :x: | **switch Node should handle flow and global contexts with JSONata expression** |
| :x: | **switch Node should handle flow context** |
| :x: | **switch Node should handle global context** |
| :x: | **switch Node should handle invalid jsonata expression** |
| :x: | **switch Node should handle persistable flow and global contexts with JSONata expression** |
| :x: | **switch Node should handle persistable flow context** |
| :x: | **switch Node should handle persistable global context** |
| :x: | **switch Node should handle too many pending messages** |
| :x: | **switch Node should match if a payload has a required property** |
| :x: | **switch Node should match regex** |
| :x: | **switch Node should match regex with ignore-case flag set true** |
| :x: | **switch Node should not match if a payload does not have a required property** |
| :x: | **switch Node should not match if the key is not a string** |
| :x: | **switch Node should not match if the parent object does not exist - null** |
| :x: | **switch Node should not match if the parent object does not exist - undefined** |
| :x: | **switch Node should not match regex with ignore-case flag set false** |
| :x: | **switch Node should not match regex with ignore-case flag unset** |
| :x: | **switch Node should not repair message sequence for each port** |
| :x: | **switch Node should repair message sequence for each port** |
| :x: | **switch Node should repair message sequence for each port (overlap)** |
| :x: | **switch Node should return nothing when the payload does equal to desired numeric value** |
| :x: | **switch Node should return nothing when the payload does equal to desired string** |
| :x: | **switch Node should return nothing when the payload doesn't contain desired string** |
| :x: | **switch Node should return nothing when the payload doesn't contain desired string** |
| :x: | **switch Node should return nothing when the payload doesn't equal to desired numeric value** |
| :x: | **switch Node should return nothing when the payload doesn't equal to desired string** |
| :x: | **switch Node should return nothing when the payload doesn't match regex** |
| :x: | **switch Node should return nothing when the payload is not greater than desired string** |
| :x: | **switch Node should return nothing when the payload is not greater than desired string** |
| :x: | **switch Node should return nothing when the payload is not less than desired string** |
| :x: | **switch Node should take head of message sequence (no repair)** |
| :x: | **switch Node should take head of message sequence (repair)** |
| :x: | **switch Node should take head of message sequence (w. JSONata)** |
| :x: | **switch Node should take head of message sequence (w. context)** |
| :x: | **switch Node should take slice of message sequence (no repair)** |
| :x: | **switch Node should take slice of message sequence (repair)** |
| :x: | **switch Node should take tail of message sequence (no repair)** |
| :x: | **switch Node should take tail of message sequence (repair)** |
| :x: | **switch Node should treat non-existant msg property conditional as undefined** |
| :x: | **switch Node should use a nested message property to compare nested message property - matches** |
| :x: | **switch Node should use a nested message property to compare nested message property - no match** |
| :x: | **switch Node should use a nested message property to compare value - matches** |
| :x: | **switch Node should use a nested message property to compare value - no match** |
| :x: | **switch Node stops after first statement** |
### change
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~change Node #change changes the number using global context property~~ |
| :white_check_mark: | ~~change Node #change changes the number using persistable global context property~~ |
| :white_check_mark: | ~~change Node #change changes the value - new rule format~~ |
| :white_check_mark: | ~~change Node #change changes the value and doesnt change type of the flow context for partial match~~ |
| :white_check_mark: | ~~change Node #change changes the value and doesnt change type of the message property for partial match~~ |
| :white_check_mark: | ~~change Node #change changes the value and doesnt change type of the persistable flow context for partial match~~ |
| :white_check_mark: | ~~change Node #change changes the value and type of the flow context if a complete match~~ |
| :white_check_mark: | ~~change Node #change changes the value and type of the message property if a complete match - boolean~~ |
| :white_check_mark: | ~~change Node #change changes the value and type of the message property if a complete match - number~~ |
| :white_check_mark: | ~~change Node #change changes the value and type of the persistable flow context if a complete match~~ |
| :white_check_mark: | ~~change Node #change changes the value of a multi-level message property~~ |
| :white_check_mark: | ~~change Node #change changes the value of the global context~~ |
| :white_check_mark: | ~~change Node #change changes the value of the message property~~ |
| :white_check_mark: | ~~change Node #change changes the value of the message property based on a regex~~ |
| :white_check_mark: | ~~change Node #change changes the value of the persistable global context~~ |
| :white_check_mark: | ~~change Node #change changes the value using boolean - boolean flow context~~ |
| :white_check_mark: | ~~change Node #change changes the value using boolean - boolean payload~~ |
| :white_check_mark: | ~~change Node #change changes the value using boolean - boolean persistable flow context~~ |
| :white_check_mark: | ~~change Node #change changes the value using boolean - string payload~~ |
| :white_check_mark: | ~~change Node #change changes the value using flow context property~~ |
| :white_check_mark: | ~~change Node #change changes the value using global context property~~ |
| :white_check_mark: | ~~change Node #change changes the value using msg property~~ |
| :white_check_mark: | ~~change Node #change changes the value using number - number flow context~~ |
| :white_check_mark: | ~~change Node #change changes the value using number - number payload~~ |
| :white_check_mark: | ~~change Node #change changes the value using number - number persistable flow context~~ |
| :white_check_mark: | ~~change Node #change changes the value using number - string payload~~ |
| :white_check_mark: | ~~change Node #change changes the value using persistable flow context property~~ |
| :white_check_mark: | ~~change Node #change changes the value using persistable global context property~~ |
| :white_check_mark: | ~~change Node #change env var changes the value using env property~~ |
| :white_check_mark: | ~~change Node #change sends unaltered message if a changed multi-level message property does not exist~~ |
| :white_check_mark: | ~~change Node #change sends unaltered message if the changed message property does not exist~~ |
| :white_check_mark: | ~~change Node #change supports regex groups~~ |
| :white_check_mark: | ~~change Node #change supports regex groups - new rule format~~ |
| :white_check_mark: | ~~change Node #delete deletes the value of a multi-level message property~~ |
| :white_check_mark: | ~~change Node #delete deletes the value of global context property~~ |
| :white_check_mark: | ~~change Node #delete deletes the value of persistable global context property~~ |
| :white_check_mark: | ~~change Node #delete deletes the value of the message property~~ |
| :white_check_mark: | ~~change Node #delete sends unaltered message if a deleted multi-level message property does not exist~~ |
| :white_check_mark: | ~~change Node #delete sends unaltered message if the deleted message property does not exist~~ |
| :white_check_mark: | ~~change Node #move moves the value of a message property object~~ |
| :white_check_mark: | ~~change Node #move moves the value of a message property object to a sub-property~~ |
| :white_check_mark: | ~~change Node #move moves the value of a message property object to itself~~ |
| :white_check_mark: | ~~change Node #move moves the value of a message sub-property object to a property~~ |
| :white_check_mark: | ~~change Node #move moves the value of the message property~~ |
| :white_check_mark: | ~~change Node #set changes the value to a boolean value~~ |
| :white_check_mark: | ~~change Node #set changes the value to a buffer object~~ |
| :white_check_mark: | ~~change Node #set changes the value to a js object~~ |
| :white_check_mark: | ~~change Node #set changes the value to a number~~ |
| :white_check_mark: | ~~change Node #set changes the value to flow context property~~ |
| :white_check_mark: | ~~change Node #set changes the value to global context property~~ |
| :white_check_mark: | ~~change Node #set changes the value to persistable flow context property~~ |
| :white_check_mark: | ~~change Node #set changes the value to persistable global context property~~ |
| :white_check_mark: | ~~change Node #set does not set other properties using = inside to property~~ |
| :white_check_mark: | ~~change Node #set doesn't set the value of a message property when the 'to' message property does not exist~~ |
| :white_check_mark: | ~~change Node #set env var sets the value using env property~~ |
| :white_check_mark: | ~~change Node #set env var sets the value using env property from group~~ |
| :white_check_mark: | ~~change Node #set env var sets the value using env property from nested group~~ |
| :white_check_mark: | ~~change Node #set env var sets the value using env property from tab~~ |
| :white_check_mark: | ~~change Node #set overrides the value of a message property when the 'to' message property does not exist~~ |
| :white_check_mark: | ~~change Node #set sets the message property to null when the 'to' message property equals null~~ |
| :white_check_mark: | ~~change Node #set sets the value and type of the message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a message property to another message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a message property using a nested property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a message property using a nested property in flow context~~ |
| :white_check_mark: | ~~change Node #set sets the value of a multi-level message property to another multi-level message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a nested flow context property using a message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of a nested message property using a message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of an already set multi-level message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of an empty multi-level message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of global context property~~ |
| :white_check_mark: | ~~change Node #set sets the value of persistable global context property~~ |
| :white_check_mark: | ~~change Node #set sets the value of the message property~~ |
| :white_check_mark: | ~~change Node #set sets the value of the message property to the current timestamp~~ |
| :white_check_mark: | ~~change Node #set splits dot delimited properties into objects~~ |
| :white_check_mark: | ~~change Node - multiple rules applies multiple rules in order~~ |
| :white_check_mark: | ~~change Node - multiple rules can access persistable global & flow context property~~ |
| :white_check_mark: | ~~change Node - multiple rules can access two persistable flow context property~~ |
| :white_check_mark: | ~~change Node - multiple rules can access two persistable global context property~~ |
| :white_check_mark: | ~~change Node - multiple rules handles multiple rules~~ |
| :white_check_mark: | ~~change Node should load defaults if set to change~~ |
| :white_check_mark: | ~~change Node should load defaults if set to replace~~ |
| :white_check_mark: | ~~change Node should load node with defaults~~ |
| :white_check_mark: | ~~change Node should no-op if there are no rules~~ |
| :x: | **change Node #change reports invalid fromValue** |
| :x: | **change Node #change reports invalid regex** |
| :x: | **change Node #set changes the value using flow context with jsonata** |
| :x: | **change Node #set changes the value using global context with jsonata** |
| :x: | **change Node #set changes the value using jsonata** |
| :x: | **change Node #set changes the value using persistable flow context with jsonata** |
| :x: | **change Node #set changes the value using persistable global context with jsonata** |
| :x: | **change Node #set deep copies the property if selected** |
| :x: | **change Node #set reports invalid jsonata expression** |
| :x: | **change Node #set sets the value of a message property using a nested property in flow context** |
### range
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~range Node clamps numbers within a range - below min~~ |
| :white_check_mark: | ~~range Node clamps numbers within a range - over max~~ |
| :white_check_mark: | ~~range Node drops msg if in drop mode and input outside range~~ |
| :white_check_mark: | ~~range Node just passes on msg if payload not present~~ |
| :white_check_mark: | ~~range Node ranges numbers down such as centimetres to metres~~ |
| :white_check_mark: | ~~range Node ranges numbers up tenfold~~ |
| :white_check_mark: | ~~range Node reports if input is not a number~~ |
| :white_check_mark: | ~~range Node wraps numbers around say for degree/rotation reading 0~~ |
| :white_check_mark: | ~~range Node wraps numbers around say for degree/rotation reading 1/3~~ |
| :white_check_mark: | ~~range Node wraps numbers around say for degree/rotation reading 1/4~~ |
| :white_check_mark: | ~~range Node wraps numbers down say for degree/rotation reading 1/2~~ |
| :white_check_mark: | ~~range Node wraps numbers down say for degree/rotation reading 1/4~~ |
| :x: | **range Node should load some defaults** |
### template
| Status | Spec Test |
| --- | --- |
| :x: | **template node env var should modify payload from env variable** |
| :x: | **template node should be able to overwrite msg.template using the template from msg.template** |
| :x: | **template node should handle block contexts objects** |
| :x: | **template node should handle deeper objects** |
| :x: | **template node should handle escape characters in Mustache format and JSON output mode** |
| :x: | **template node should handle if the field isn't set** |
| :x: | **template node should handle missing node context** |
| :x: | **template node should handle nested context tags - property not set** |
| :x: | **template node should handle nested context tags - property set** |
| :x: | **template node should modify flow context** |
| :x: | **template node should modify global context** |
| :x: | **template node should modify payload from flow context** |
| :x: | **template node should modify payload from global context** |
| :x: | **template node should modify payload from msg.template** |
| :x: | **template node should modify payload from persistable flow & global context** |
| :x: | **template node should modify payload from persistable flow context** |
| :x: | **template node should modify payload from persistable global context** |
| :x: | **template node should modify payload from two persistable flow context** |
| :x: | **template node should modify payload from two persistable global context** |
| :x: | **template node should modify payload in plain text mode** |
| :x: | **template node should modify payload using node-configured template** |
| :x: | **template node should modify persistable flow context** |
| :x: | **template node should modify persistable global context** |
| :x: | **template node should modify the configured property using msg.template** |
| :x: | **template node should raise error if passed bad template** |
### delay
| Status | Spec Test |
| --- | --- |
| :x: | **delay Node calls done when queue is flushed (queue/timed)** |
| :x: | **delay Node calls done when queue is reset (queue/timed)** |
| :x: | **delay Node calls done when queued message is cleared (type: delay)** |
| :x: | **delay Node calls done when queued message is cleared (type: delayv)** |
| :x: | **delay Node calls done when queued message is cleared (type: random)** |
| :x: | **delay Node calls done when queued message is emitted (type: delay)** |
| :x: | **delay Node calls done when queued message is emitted (type: delay)** |
| :x: | **delay Node calls done when queued message is emitted (type: delayv)** |
| :x: | **delay Node calls done when queued message is flushed (type: delay)** |
| :x: | **delay Node calls done when queued message is flushed (type: delayv)** |
| :x: | **delay Node calls done when queued message is flushed (type: random)** |
| :x: | **delay Node calls done when queued messages are sent (queue)** |
| :x: | **delay Node calls done when queued messages are sent (timed)** |
| :x: | **delay Node calls done when rated message is emitted (drop: false)** |
| :x: | **delay Node calls done when rated message is emitted (drop: true)** |
| :x: | **delay Node calls done when rated message is flushed** |
| :x: | **delay Node can flush delay queue** |
| :x: | **delay Node can flush rate limit queue** |
| :x: | **delay Node can full flush and reset rate limit queue** |
| :x: | **delay Node can part flush and reset rate limit queue** |
| :x: | **delay Node can part flush delay queue** |
| :x: | **delay Node can part flush rate limit queue** |
| :x: | **delay Node can part push to front of rate limit queue** |
| :x: | **delay Node can reset delay queue** |
| :x: | **delay Node can reset rate limit queue** |
| :x: | **delay Node delays the message in days** |
| :x: | **delay Node delays the message in days** |
| :x: | **delay Node delays the message in hours** |
| :x: | **delay Node delays the message in hours** |
| :x: | **delay Node delays the message in milliseconds** |
| :x: | **delay Node delays the message in minutes** |
| :x: | **delay Node delays the message in seconds** |
| :x: | **delay Node handles delay queue** |
| :x: | **delay Node handles timed queue** |
| :x: | **delay Node limits the message rate to 1 per 2 seconds** |
| :x: | **delay Node limits the message rate to 1 per 2 seconds, 4 seconds, with drop** |
| :x: | **delay Node limits the message rate to 1 per second** |
| :x: | **delay Node limits the message rate to 1 per second, 4 seconds, with drop** |
| :x: | **delay Node limits the message rate to 2 per second, 5 seconds, with drop** |
| :x: | **delay Node limits the message rate to 2 per second, 5 seconds, with drop, 2nd output** |
| :x: | **delay Node limits the message rate to 2 per seconds, 2 seconds** |
| :x: | **delay Node limits the message rate using msg.rate** |
| :x: | **delay Node limits the message rate with drop using msg.rate** |
| :x: | **delay Node randomly delays the message in milliseconds** |
| :x: | **delay Node randomly delays the message in minutes** |
| :x: | **delay Node randomly delays the message in seconds** |
| :x: | **delay Node should be able to set rate to hour** |
| :x: | **delay Node should be able to set rate to minute** |
| :x: | **delay Node should be loaded** |
| :x: | **delay Node variable delay is the default if msg.delay not specified** |
| :x: | **delay Node variable delay is zero if msg.delay is negative** |
| :x: | **delay Node variable delay is zero if msg.delay is zero** |
| :x: | **delay Node variable delay set by msg.delay the message in milliseconds** |
### trigger
| Status | Spec Test |
| --- | --- |
| :x: | **trigger node messaging API should call done() when first message has been processed** |
| :x: | **trigger node messaging API should call done() when it receives reset message** |
| :x: | **trigger node should be able output the 2nd payload** |
| :x: | **trigger node should be able output the 2nd payload and handle multiple topics** |
| :x: | **trigger node should be able to apply mustache templates to payloads** |
| :x: | **trigger node should be able to extend the delay** |
| :x: | **trigger node should be able to extend the delay (but with no 2nd output)** |
| :x: | **trigger node should be able to extend the delay and output the most recent payload** |
| :x: | **trigger node should be able to not output anything on first trigger** |
| :x: | **trigger node should be able to not output anything on second edge** |
| :x: | **trigger node should be able to reset correctly having not output anything on second edge** |
| :x: | **trigger node should be able to return things from flow and global context variables** |
| :x: | **trigger node should be able to return things from multiple persistable flow & global context variables** |
| :x: | **trigger node should be able to return things from multiple persistable flow context variables** |
| :x: | **trigger node should be able to return things from multiple persistable global context variables** |
| :x: | **trigger node should be able to return things from persistable flow and global context variables** |
| :x: | **trigger node should be able to send 2nd message to a 2nd output** |
| :x: | **trigger node should be able to set a repeat, and clear loop by reset** |
| :x: | **trigger node should be able to set delay in hours** |
| :x: | **trigger node should be able to set delay in minutes** |
| :x: | **trigger node should be able to set delay in seconds** |
| :x: | **trigger node should be able to set infinite timeout, and clear timeout** |
| :x: | **trigger node should be able to set infinite timeout, and clear timeout by boolean false** |
| :x: | **trigger node should be able to set infinite timeout, and clear timeout by boolean true** |
| :x: | **trigger node should be able to set infinite timeout, and clear timeout by message** |
| :x: | **trigger node should be loaded with correct defaults** |
| :x: | **trigger node should handle multiple other properties individually if asked to do so** |
| :x: | **trigger node should handle multiple topics as one if not asked to handle** |
| :x: | **trigger node should handle multiple topics individually if asked to do so** |
| :x: | **trigger node should handle multiple topics individually, and extend one, if asked to do so** |
| :x: | **trigger node should handle string null as null** |
| :x: | **trigger node should handle string null as null on op2** |
| :x: | **trigger node should handle true and false as strings and delay of 0** |
| :x: | **trigger node should ignore any other inputs while triggered if extend is false** |
| :x: | **trigger node should ignore msg.delay if overrideDelay not set** |
| :x: | **trigger node should output 1 then 0 when triggered (default)** |
| :x: | **trigger node should output 1st value when triggered (bin)** |
| :x: | **trigger node should output 1st value when triggered (bool)** |
| :x: | **trigger node should output 1st value when triggered (env)** |
| :x: | **trigger node should output 1st value when triggered (json)** |
| :x: | **trigger node should output 1st value when triggered (num)** |
| :x: | **trigger node should output 1st value when triggered (str)** |
| :x: | **trigger node should output 2st value when triggered (bin)** |
| :x: | **trigger node should output 2st value when triggered (bool)** |
| :x: | **trigger node should output 2st value when triggered (env)** |
| :x: | **trigger node should output 2st value when triggered (json)** |
| :x: | **trigger node should output 2st value when triggered (num)** |
| :x: | **trigger node should output 2st value when triggered (str)** |
| :x: | **trigger node should use msg.delay if overrideDelay is set** |
### rbe
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~rbe node should ignore multiple topics if told to (rbe)~~ |
| :white_check_mark: | ~~rbe node should not send output if more than x away from original value (narrowband in step mode)~~ |
| :white_check_mark: | ~~rbe node should not send output if more than x away from original value (narrowband)~~ |
| :white_check_mark: | ~~rbe node should not send output if x away or greater from original value (narrowbandEq)~~ |
| :white_check_mark: | ~~rbe node should only send output if another chosen property changes - foo (rbe)~~ |
| :white_check_mark: | ~~rbe node should only send output if more than x away from original value (deadband)~~ |
| :white_check_mark: | ~~rbe node should only send output if more than x% away from original value (deadband)~~ |
| :white_check_mark: | ~~rbe node should only send output if payload changes - ignoring first value (rbei)~~ |
| :white_check_mark: | ~~rbe node should only send output if payload changes - with multiple topics (rbe)~~ |
| :white_check_mark: | ~~rbe node should only send output if x away from original value (deadbandEq)~~ |
| :white_check_mark: | ~~rbe node should send output if gap is 0 and input doesnt change (narrowband)~~ |
| :white_check_mark: | ~~rbe node should send output if queue is reset (rbe)~~ |
| :x: | **rbe node should be loaded with correct defaults** |
| :x: | **rbe node should warn if no number found in deadband mode** |
## subflow
### subflow
| Status | Spec Test |
| --- | --- |
| :white_check_mark: | ~~subflow should access NR_NODE_PATH env var within subflow instance~~ |
| :white_check_mark: | ~~subflow should access env var of group~~ |
| :white_check_mark: | ~~subflow should access env var of nested group~~ |
| :white_check_mark: | ~~subflow should access env var of parent subflow instance~~ |
| :white_check_mark: | ~~subflow should access env var of parent subflow template~~ |
| :white_check_mark: | ~~subflow should access env var of subflow instance~~ |
| :white_check_mark: | ~~subflow should access env var of subflow template~~ |
| :white_check_mark: | ~~subflow should access env var of tab~~ |
| :white_check_mark: | ~~subflow should access last env var with same name~~ |
| :white_check_mark: | ~~subflow should access typed value of env var~~ |
| :white_check_mark: | ~~subflow should define subflow~~ |
| :white_check_mark: | ~~subflow should overwrite env var of subflow template by env var of subflow instance~~ |
| :white_check_mark: | ~~subflow should pass data to/from nested subflow~~ |
| :white_check_mark: | ~~subflow should pass data to/from subflow~~ |
